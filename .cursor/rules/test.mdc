---
description: Modern React 19 patterns and performance best practices for Korean trade platform
globs: 
alwaysApply: true
---

# Modern React Patterns & Performance Guide

## Core React 19 Principles

### New Hooks & Patterns
- **TanStack Query integration** - recommended for server state management
- **TanStack Router file-based routing** - type-safe navigation patterns
- **TanStack Query `use()` hook** - experimental React 19 compatible API
- **React 19 `use()` for context** - consume React context without useContext
- **Refs as props** - no more forwardRef needed, pass refs like regular props
- **Actions pattern** - leverage React 19's built-in form actions
- **Automatic optimizations** - React Compiler will handle most memoization (when available)

### TanStack Router Patterns

**File-based Routing Structure:**
```typescript
// routes/__root.tsx - Root layout
export const Route = createRootRoute({
  component: RootComponent,
});

// routes/index.tsx - Home page  
export const Route = createFileRoute('/')({
  component: HomePage,
});

// routes/hscode/$hsCode.tsx - Dynamic route
export const Route = createFileRoute('/hscode/$hsCode')({
  component: HSCodeDetail,
  loader: ({ params }) => queryClient.ensureQueryData({
    queryKey: ['hscode', params.hsCode],
    queryFn: () => api.getHSCodeInfo(params.hsCode),
  }),
});
```

**Type-safe Navigation:**
```typescript
// 🎯 Recommended: Type-safe navigation with search params
const navigate = useNavigate();

const handleSearch = (query: string) => {
  navigate({ 
    to: '/search', 
    search: { q: query, filters: selectedFilters } 
  });
};

// 🎯 Route-specific hooks for params and search
const { hsCode } = Route.useParams(); // Type-safe params
const { q, filters } = Route.useSearch(); // Type-safe search params
```

**Router + TanStack Query Integration:**
```typescript
// 🎯 Recommended: Prefetch data in route loaders
export const Route = createFileRoute('/analysis/$sessionId')({
  component: AnalysisPage,
  loader: async ({ params }) => {
    // Prefetch data before component renders
    await queryClient.ensureQueryData({
      queryKey: ['analysisSession', params.sessionId],
      queryFn: () => claudeApi.getAnalysisSession(params.sessionId),
    });
  },
  pendingComponent: () => <AnalysisSpinner />,
  errorComponent: ({ error }) => <ErrorDisplay error={error} />,
});
```

### Performance Optimization Guidelines

#### Memoization Recommendations (Until React Compiler)
Consider these patterns when optimizing performance:

**useCallback - Function Memoization:**
```typescript
// 🎯 Consider when passing callbacks to optimized child components
const handleSubmit = useCallback((data: FormData) => {
  // Logic here
}, [dependency1, dependency2]);

// 💡 Alternative: Simple functions often don't need memoization
const simpleHandler = () => console.log('click'); // Usually fine as-is
```

**useMemo - Value Memoization:**
```typescript
// 🎯 Recommended for expensive calculations
const expensiveValue = useMemo(() => {
  return heavyComputation(data);
}, [data]);

// 🎯 Consider for object/array references passed to children
const config = useMemo(() => ({
  apiKey: process.env.API_KEY,
  baseUrl: '/api/v1'
}), []);

// 💡 Note: Primitive values rarely need memoization
const simpleValue = data.length; // Memoization usually unnecessary
```

#### useEffect Best Practices (Client State & Side Effects)

**When to Use useEffect (Not for Server Data):**
```typescript
// ✅ DOM manipulation and browser APIs
useEffect(() => {
  document.title = `분석 결과: ${hsCode}`;
}, [hsCode]);

// ✅ Event listeners and cleanup
useEffect(() => {
  const handleKeyPress = (e: KeyboardEvent) => {
    if (e.key === 'Escape') closeModal();
  };
  
  window.addEventListener('keydown', handleKeyPress);
  return () => window.removeEventListener('keydown', handleKeyPress);
}, []);

// ✅ Local storage synchronization
useEffect(() => {
  localStorage.setItem('userPreferences', JSON.stringify(preferences));
}, [preferences]);

// ✅ WebSocket connections (not for REST API calls)
useEffect(() => {
  const ws = new WebSocket('/api/monitoring');
  ws.onmessage = (event) => {
    setRealTimeUpdates(JSON.parse(event.data));
  };
  
  return () => ws.close();
}, []);

// ❌ Don't use for server data fetching (use TanStack Query)
useEffect(() => {
  fetch('/api/data').then(r => r.json()).then(setData); // Wrong!
}, []);
```

**Server State vs Client State Separation:**
```typescript
// ✅ Server State - Use TanStack Query
const { data: hsCodeData } = useQuery({
  queryKey: ['hscode', code],
  queryFn: () => api.getHSCodeInfo(code),
});

// ✅ Client State - Use useState + useEffect if needed
const [selectedTab, setSelectedTab] = useState('basic');
const [isModalOpen, setIsModalOpen] = useState(false);

useEffect(() => {
  // Client-side logic only
  if (isModalOpen) {
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = 'unset'; };
  }
}, [isModalOpen]);
```

**Data Fetching Patterns with TanStack Query:**
```typescript
// ✅ TanStack Query - Preferred approach for server state
const { data, isLoading, error } = useQuery({
  queryKey: ['hsCodeAnalysis', query],
  queryFn: () => claudeApi.analyzeHSCode(query),
  enabled: !!query, // Only run when query exists
  staleTime: 5 * 60 * 1000, // 5 minutes
  gcTime: 10 * 60 * 1000, // 10 minutes
});

// ✅ TanStack Query Suspense approach
const { data } = useSuspenseQuery({
  queryKey: ['cargoTracking', cargoNumber],
  queryFn: () => customsApi.trackCargo(cargoNumber),
});

// ✅ TanStack Query use() hook (experimental - React 19 compatible)
import { use } from '@tanstack/react-query';

const query = use({
  queryKey: ['tradeStatistics', hsCode],
  queryFn: () => comtradeApi.getStatistics(hsCode),
});

// ❌ Avoid manual useEffect for server data
const [data, setData] = useState(null);
useEffect(() => {
  // Don't manage server state manually
  fetchData().then(setData);
}, []);
```

## State Management with Zustand

### Store Design Patterns

**Domain-separated Stores:**
```typescript
// 🎯 Recommended: Separate stores by domain
type AuthStore = {
  user: User | null;
  isLoading: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
};

export const useAuthStore = create<AuthStore>((set, get) => ({
  user: null,
  isLoading: false,
  login: async (credentials) => {
    set({ isLoading: true });
    try {
      const user = await authApi.login(credentials);
      set({ user, isLoading: false });
    } catch (error) {
      set({ isLoading: false });
      throw error;
    }
  },
  logout: () => set({ user: null }),
}));

// 🎯 Consider: Separate UI state from business logic
type UIStore = {
  sidebarOpen: boolean;
  currentTheme: 'light' | 'dark';
  toggleSidebar: () => void;
  setTheme: (theme: 'light' | 'dark') => void;
};

export const useUIStore = create<UIStore>((set) => ({
  sidebarOpen: false,
  currentTheme: 'light',
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
  setTheme: (theme) => set({ currentTheme: theme }),
}));
```

**Store Integration with TanStack Query:**
```typescript
// 🎯 Recommended: Zustand for client state, TanStack Query for server state
const useBookmarkStore = create<BookmarkStore>((set, get) => ({
  selectedFilters: [],
  sortOrder: 'recent',
  
  // Client state actions
  setFilters: (filters) => set({ selectedFilters: filters }),
  setSortOrder: (order) => set({ sortOrder: order }),
  
  // 💡 Note: Server operations delegated to TanStack Query
  // Don't put server data directly in Zustand stores
}));

// Component usage
const BookmarkList = () => {
  // Server state from TanStack Query
  const { data: bookmarks } = useQuery({
    queryKey: ['bookmarks'],
    queryFn: () => api.getBookmarks(),
  });
  
  // Client state from Zustand
  const { selectedFilters, setFilters } = useBookmarkStore();
  
  const filteredBookmarks = useMemo(() => 
    bookmarks?.filter(bookmark => 
      selectedFilters.every(filter => bookmark.tags.includes(filter))
    ), [bookmarks, selectedFilters]
  );
  
  return <BookmarkGrid bookmarks={filteredBookmarks} />;
};
```

**Cross-Store Communication:**
```typescript
// 🎯 Consider: Explicit cross-store dependencies
type NotificationStore = {
  notifications: Notification[];
  addNotification: (notification: Omit<Notification, 'id'>) => void;
  removeNotification: (id: string) => void;
};

export const useNotificationStore = create<NotificationStore>((set) => ({
  notifications: [],
  addNotification: (notification) => {
    const id = crypto.randomUUID();
    set((state) => ({
      notifications: [...state.notifications, { ...notification, id }],
    }));
  },
  removeNotification: (id) => 
    set((state) => ({
      notifications: state.notifications.filter(n => n.id !== id),
    })),
}));

// Usage in auth store
const useAuthStore = create<AuthStore>((set, get) => ({
  login: async (credentials) => {
    try {
      // ... login logic
      useNotificationStore.getState().addNotification({
        type: 'success',
        message: '로그인되었습니다.',
      });
    } catch (error) {
      // Handle error
    }
  },
}));
```

## Form Handling with React Hook Form + Zod

### Validation Patterns

**Schema-first Approach:**
```typescript
// 🎯 Recommended: Define schemas separately for reusability
const hsCodeSearchSchema = z.object({
  query: z.string().min(1, '검색어를 입력해주세요'),
  category: z.enum(['all', 'electronics', 'textiles']).optional(),
  country: z.string().optional(),
});

type HSCodeSearchForm = z.infer<typeof hsCodeSearchSchema>;

// Component usage
const HSCodeSearchForm = () => {
  const { register, handleSubmit, formState: { errors } } = useForm<HSCodeSearchForm>({
    resolver: zodResolver(hsCodeSearchSchema),
    defaultValues: {
      query: '',
      category: 'all',
    },
  });

  const searchMutation = useMutation({
    mutationFn: (data: HSCodeSearchForm) => claudeApi.analyzeHSCode(data),
    onSuccess: (result) => {
      // Navigate to results
      navigate({ to: '/analysis/$sessionId', params: { sessionId: result.sessionId } });
    },
  });

  const onSubmit = (data: HSCodeSearchForm) => {
    searchMutation.mutate(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="query">상품명 또는 설명</label>
        <input
          id="query"
          {...register('query')}
          placeholder="예: 아이폰 15"
        />
        {errors.query && <span className="error">{errors.query.message}</span>}
      </div>
      
      <button type="submit" disabled={searchMutation.isPending}>
        {searchMutation.isPending ? '분석 중...' : 'HS Code 분석'}
      </button>
    </form>
  );
};
```

**Complex Form Patterns:**
```typescript
// 🎯 Consider: Nested objects and arrays
const userPreferencesSchema = z.object({
  profile: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  notifications: z.object({
    email: z.boolean(),
    push: z.boolean(),
  }),
  bookmarkCategories: z.array(z.string()).min(1, '최소 하나의 카테고리를 선택해주세요'),
});

// 💡 Alternative: Field arrays for dynamic forms
const monitoringSetupSchema = z.object({
  targets: z.array(z.object({
    type: z.enum(['hs_code', 'cargo']),
    value: z.string(),
    alertFrequency: z.enum(['immediate', 'daily', 'weekly']),
  })).min(1),
});

// Use with useFieldArray for dynamic lists
const { fields, append, remove } = useFieldArray({
  control,
  name: 'targets',
});
```

## Data Visualization with Tremor React

### Chart Component Patterns

**Trade Statistics Visualization:**
```typescript
// 🎯 Recommended: Separate data transformation from visualization
const TradeStatisticsChart = ({ hsCode }: { hsCode: string }) => {
  const { data: statistics } = useQuery({
    queryKey: ['tradeStatistics', hsCode],
    queryFn: () => comtradeApi.getStatistics(hsCode),
  });

  const chartData = useMemo(() => {
    if (!statistics) return [];
    
    return statistics.monthlyData.map(item => ({
      month: format(new Date(item.date), 'MMM yyyy'),
      수출액: item.exportValue / 1000000, // Convert to millions
      수입액: item.importValue / 1000000,
      거래량: item.volume,
    }));
  }, [statistics]);

  if (!chartData.length) return <div>데이터가 없습니다</div>;

  return (
    <div className="space-y-6">
      <AreaChart
        data={chartData}
        index="month"
        categories={['수출액', '수입액']}
        colors={['blue', 'green']}
        valueFormatter={(value) => `${value}M`}
        yAxisLabel="금액 (백만 달러)"
        className="h-72"
      />
      
      <BarChart
        data={chartData}
        index="month"
        categories={['거래량']}
        colors={['slate']}
        valueFormatter={(value) => `${value.toLocaleString()}톤`}
        yAxisLabel="거래량 (톤)"
        className="h-64"
      />
    </div>
  );
};
```

**Responsive Chart Patterns:**
```typescript
// 🎯 Consider: Responsive breakpoints for chart layouts
const HSCodeDashboard = () => {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <Card>
        <CardHeader>
          <CardTitle>월별 수출입 추이</CardTitle>
        </CardHeader>
        <CardContent>
          <LineChart
            data={monthlyData}
            index="month" 
            categories={['export', 'import']}
            colors={['blue', 'red']}
            className="h-64 sm:h-72"
            showLegend={true}
            showTooltip={true}
          />
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader>
          <CardTitle>주요 거래국</CardTitle>
        </CardHeader>
        <CardContent>
          <DonutChart
            data={countryData}
            category="value"
            index="country"
            colors={['blue', 'cyan', 'indigo', 'violet']}
            className="h-64"
            showLabel={true}
          />
        </CardContent>
      </Card>
    </div>
  );
};
```

## Toast Notifications with Sonner

### Notification Patterns

**Global Toast Management:**
```typescript
// 🎯 Recommended: Consistent toast patterns across app
import { toast } from 'sonner';

// Success patterns
const handleSuccessfulBookmark = (itemName: string) => {
  toast.success('북마크가 추가되었습니다', {
    description: `${itemName}을(를) 모니터링 목록에 추가했습니다`,
    action: {
      label: '보기',
      onClick: () => navigate({ to: '/dashboard' }),
    },
  });
};

// Error patterns
const handleAnalysisError = (error: Error) => {
  toast.error('분석 중 오류가 발생했습니다', {
    description: error.message,
    action: {
      label: '다시 시도',
      onClick: () => retryAnalysis(),
    },
  });
};

// Loading patterns
const handleLongRunningAnalysis = () => {
  const loadingToast = toast.loading('HS Code 분석 중...', {
    description: '멀티스텝 분석을 진행하고 있습니다',
  });

  // Update when complete
  analysisPromise
    .then((result) => {
      toast.success('분석이 완료되었습니다', { 
        id: loadingToast,
        description: `${result.hsCode} 분류 결과를 확인하세요`,
      });
    })
    .catch((error) => {
      toast.error('분석에 실패했습니다', { 
        id: loadingToast,
        description: error.message,
      });
    });
};
```

**Integration with Mutations:**
```typescript
// 🎯 Consider: Automatic toast notifications with TanStack Query
const bookmarkMutation = useMutation({
  mutationFn: (item: BookmarkItem) => api.addBookmark(item),
  onSuccess: (data) => {
    toast.success('북마크가 추가되었습니다');
    queryClient.invalidateQueries({ queryKey: ['bookmarks'] });
  },
  onError: (error) => {
    toast.error('북마크 추가에 실패했습니다', {
      description: error.message,
    });
  },
});

// Custom hook for common patterns
const useBookmarkActions = () => {
  const queryClient = useQueryClient();
  
  const addBookmark = useMutation({
    mutationFn: api.addBookmark,
    onMutate: async (newBookmark) => {
      // Optimistic update
      const previousBookmarks = queryClient.getQueryData(['bookmarks']);
      queryClient.setQueryData(['bookmarks'], (old: BookmarkItem[]) => 
        [...(old || []), { ...newBookmark, id: 'temp-' + Date.now() }]
      );
      
      toast.promise(
        Promise.resolve(),
        {
          loading: '북마크 추가 중...',
          success: '북마크가 추가되었습니다',
          error: '북마크 추가에 실패했습니다',
        }
      );
      
      return { previousBookmarks };
    },
    onError: (error, variables, context) => {
      // Rollback on error
      queryClient.setQueryData(['bookmarks'], context?.previousBookmarks);
    },
  });
  
  return { addBookmark };
};
```

### TypeScript Patterns
Use `type` keyword instead of `interface`:

```typescript
// ✅ Preferred approach
type UserProfile = {
  id: number;
  email: string;
  preferences: UserPreferences;
};

type ApiResponse<T> = {
  success: boolean;
  data: T | null;
  message: string;
};

// ❌ Avoid interface declarations
interface UserProfile { // Don't use this
  id: number;
}
```

## Korean Development Standards

### Comment Style (Korean)
Use nominal form endings for Korean comments:

```typescript
// ✅ Correct Korean comment style
// 사용자 정보 조회 함수
const fetchUserInfo = async (userId: string) => {
  // API 호출 및 응답 처리
  return await api.get(`/users/${userId}`);
};

// 상태 변경 감지 로직
useEffect(() => {
  // 모니터링 대상 업데이트 확인
}, [monitoringTargets]);

// ❌ Avoid polite speech or non-nominal endings
// 사용자 정보를 조회하는 함수입니다 (Wrong)
// 데이터를 가져옵니다 (Wrong)
```

### Error Messages & UI Text
All user-facing text in Korean:

```typescript
const ERROR_MESSAGES = {
  NETWORK_ERROR: '서버 연결에 실패했습니다. 네트워크 상태를 확인해 주세요.',
  INVALID_HS_CODE: 'HS Code 형식이 올바르지 않습니다.',
  ANALYSIS_FAILED: 'HS Code 분석 중 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.',
} as const;
```

## Performance Monitoring

### React DevTools Integration
```typescript
// ✅ Performance debugging approach
useEffect(() => {
  if (process.env.NODE_ENV === 'development') {
    console.log('Component rendered:', { props, state });
  }
}, [props, state]);

// ✅ Profiler for production insights
const ProfiledComponent = React.memo(MyComponent);
```

### Avoiding Common Pitfalls

**Stale Closures:**
```typescript
// ❌ Stale closure problem
const [count, setCount] = useState(0);

useEffect(() => {
  const timer = setInterval(() => {
    setCount(count + 1); // Always uses initial count value
  }, 1000);
  return () => clearInterval(timer);
}, []); // Empty dependency array causes stale closure

// ✅ Correct approach with functional update
useEffect(() => {
  const timer = setInterval(() => {
    setCount(prev => prev + 1); // Uses current value
  }, 1000);
  return () => clearInterval(timer);
}, []);
```

**Object Dependencies:**
```typescript
// ❌ Object recreation on every render
const MyComponent = ({ config }) => {
  useEffect(() => {
    apiCall(config);
  }, [config]); // Runs on every render if config is recreated
};

// ✅ Memoize object references
const MyComponent = ({ rawConfig }) => {
  const config = useMemo(() => ({
    ...rawConfig,
    timestamp: Date.now()
  }), [rawConfig]);
  
  useEffect(() => {
    apiCall(config);
  }, [config]);
};
```

## Future-Proofing for React Compiler

### Preparing for Automatic Optimization
Write clean, predictable code that React Compiler can optimize:

```typescript
// ✅ Compiler-friendly patterns
const Component = ({ items }) => {
  // Simple, pure computations
  const sortedItems = items.sort((a, b) => a.name.localeCompare(b.name));
  
  // Clear data flow
  const handleClick = (item) => {
    onItemClick(item);
  };
  
  return (
    <div>
      {sortedItems.map(item => 
        <Item key={item.id} data={item} onClick={handleClick} />
      )}
    </div>
  );
};

// ✅ Avoid complex patterns that might confuse compiler
// Keep side effects in useEffect
// Use clear dependency relationships
// Minimize object mutations
```

## Integration with Project Architecture

### API Layer Compatibility
Structure components to work with TanStack Query + API abstraction:

```typescript
// ✅ Component ready for backend integration with TanStack Query
const HSCodeAnalysis = ({ query }: { query: string }) => {
  // Server state managed by TanStack Query
  const { 
    data: analysis, 
    isLoading, 
    error,
    refetch 
  } = useQuery({
    queryKey: ['hsCodeAnalysis', query],
    queryFn: () => claudeApi.analyzeHSCode(query), // API abstraction layer
    enabled: !!query,
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
    retry: 3,
  });

  // Client state for UI
  const [selectedTab, setSelectedTab] = useState('basic');

  // Side effects (not data fetching)
  useEffect(() => {
    if (analysis) {
      // Analytics tracking, notifications, etc.
      analytics.track('hs_code_analyzed', { code: analysis.hsCode });
    }
  }, [analysis]);

  if (isLoading) return <AnalysisSpinner />;
  if (error) return <ErrorDisplay error={error} onRetry={refetch} />;
  
  return (
    <AnalysisResults 
      analysis={analysis} 
      selectedTab={selectedTab}
      onTabChange={setSelectedTab}
    />
  );
};

// ✅ Custom hook pattern for reusable queries
const useHSCodeAnalysis = (query: string) => {
  return useQuery({
    queryKey: ['hsCodeAnalysis', query],
    queryFn: () => claudeApi.analyzeHSCode(query),
    enabled: !!query,
    staleTime: 5 * 60 * 1000,
  });
};
```

## Testing with Vitest & Testing Library

### Component Testing Patterns

**Setup and Configuration:**
```typescript
// vitest.config.ts recommended setup
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
  },
});

// src/test/setup.ts
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach, vi } from 'vitest';

afterEach(() => {
  cleanup();
});

// Mock Sonner toast
vi.mock('sonner', () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
    loading: vi.fn(),
    promise: vi.fn(),
  },
}));
```

**TanStack Query Testing:**
```typescript
// 🎯 Recommended: Test utility for query setup
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, beforeEach, vi } from 'vitest';

const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
});

const createTestWrapper = (queryClient: QueryClient) => {
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('HSCodeAnalysis Component', () => {
  let queryClient: QueryClient;

  beforeEach(() => {
    queryClient = createTestQueryClient();
    vi.clearAllMocks();
  });

  it('should display loading state initially', () => {
    render(
      <HSCodeAnalysis query="test query" />,
      { wrapper: createTestWrapper(queryClient) }
    );
    
    expect(screen.getByTestId('analysis-spinner')).toBeInTheDocument();
  });

  it('should handle successful analysis', async () => {
    const mockAnalysis = {
      hsCode: '1234567890',
      description: 'Test product',
      confidence: 0.95,
    };

    // Mock API response
    vi.mocked(claudeApi.analyzeHSCode).mockResolvedValue(mockAnalysis);

    render(
      <HSCodeAnalysis query="test product" />,
      { wrapper: createTestWrapper(queryClient) }
    );

    await waitFor(() => {
      expect(screen.getByText('1234567890')).toBeInTheDocument();
      expect(screen.getByText('Test product')).toBeInTheDocument();
    });
  });
});
```

**Zustand Store Testing:**
```typescript
// 🎯 Consider: Testing store logic separately
import { act, renderHook } from '@testing-library/react';
import { describe, it, expect, beforeEach } from 'vitest';

describe('useBookmarkStore', () => {
  beforeEach(() => {
    // Reset store state
    useBookmarkStore.setState({ 
      selectedFilters: [],
      sortOrder: 'recent'
    });
  });

  it('should update filters correctly', () => {
    const { result } = renderHook(() => useBookmarkStore());

    act(() => {
      result.current.setFilters(['electronics', 'export']);
    });

    expect(result.current.selectedFilters).toEqual(['electronics', 'export']);
  });

  it('should handle sort order changes', () => {
    const { result } = renderHook(() => useBookmarkStore());

    act(() => {
      result.current.setSortOrder('alphabetical');
    });

    expect(result.current.sortOrder).toBe('alphabetical');
  });
});
```

**Form Testing with React Hook Form:**
```typescript
// 🎯 Recommended: Test form validation and submission
import { fireEvent, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('HSCodeSearchForm', () => {
  it('should validate required fields', async () => {
    const user = userEvent.setup();
    render(<HSCodeSearchForm />);

    const submitButton = screen.getByRole('button', { name: /hs code 분석/i });
    
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText('검색어를 입력해주세요')).toBeInTheDocument();
    });
  });

  it('should submit form with valid data', async () => {
    const user = userEvent.setup();
    const mockMutate = vi.fn();
    
    // Mock the mutation
    vi.mocked(useMutation).mockReturnValue({
      mutate: mockMutate,
      isPending: false,
    } as any);

    render(<HSCodeSearchForm />);

    const queryInput = screen.getByLabelText(/상품명 또는 설명/i);
    const submitButton = screen.getByRole('button', { name: /hs code 분석/i });

    await user.type(queryInput, 'iPhone 15');
    await user.click(submitButton);

    expect(mockMutate).toHaveBeenCalledWith({
      query: 'iPhone 15',
      category: 'all',
    });
  });
});
```

**Integration Testing Patterns:**
```typescript
// 🎯 Consider: End-to-end workflows
describe('HS Code Analysis Workflow', () => {
  it('should complete full analysis workflow', async () => {
    const user = userEvent.setup();
    const queryClient = createTestQueryClient();

    // Mock API responses
    vi.mocked(claudeApi.analyzeHSCode).mockResolvedValue({
      sessionId: 'test-session',
      status: 'processing',
    });

    render(<App />, { wrapper: createTestWrapper(queryClient) });

    // Navigate to search page
    await user.click(screen.getByText('HS Code 분석'));

    // Fill and submit form
    const searchInput = screen.getByPlaceholderText('예: 아이폰 15');
    await user.type(searchInput, 'iPhone 15');
    await user.click(screen.getByRole('button', { name: /분석/i }));

    // Verify navigation and loading state
    await waitFor(() => {
      expect(screen.getByText('분석 중...')).toBeInTheDocument();
    });

    // Mock completion
    queryClient.setQueryData(['analysisSession', 'test-session'], {
      status: 'completed',
      result: { hsCode: '8517.12.00', description: 'Smartphones' },
    });

    // Verify results
    await waitFor(() => {
      expect(screen.getByText('8517.12.00')).toBeInTheDocument();
    });
  });
});
```

---

**Remember:** These patterns leverage TanStack Query v5.8+ for server state management while preparing for React 19 features. Separate server state (TanStack Query) from client state (useState + useEffect). As React Compiler becomes available, many memoization concerns will be handled automatically, but clean architectural separation remains essential.
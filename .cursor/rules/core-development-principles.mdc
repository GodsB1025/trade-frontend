---
description: 
globs: 
alwaysApply: true
---
---
description: React 18+ core development principles and proper useEffect usage. Covers external system synchronization, lifecycle management, dependency array best practices, and modern React patterns.
---

# React 18+ Core Development Principles

## üéØ Proper useEffect Usage Guidelines

### ‚úÖ useEffect should ONLY be used for:

**Synchronizing with external systems:**
```typescript
// ‚úÖ Correct usage - External API integration
useEffect(() => {
  const fetchUserData = async () => {
    const response = await fetch('/api/user');
    const userData = await response.json();
    setUser(userData);
  };
  
  fetchUserData();
}, [userId]); // Re-run only when userId changes

// ‚úÖ Correct usage - External library integration
useEffect(() => {
  const map = L.map('map').setView([51.505, -0.09], 13);
  
  return () => {
    map.remove(); // Cleanup function to prevent memory leaks
  };
}, []); // Run only once
```

**Browser API integration:**
```typescript
// ‚úÖ Correct usage - Direct DOM manipulation
useEffect(() => {
  document.title = `${userName}'s Dashboard`;
  
  return () => {
    document.title = 'Default Title'; // Cleanup
  };
}, [userName]);

// ‚úÖ Correct usage - Event listeners
useEffect(() => {
  const handleResize = () => setWindowWidth(window.innerWidth);
  
  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);
}, []);
```

### ‚ùå Incorrect useEffect Patterns

**State synchronization (use derived state instead):**
```typescript
// ‚ùå Incorrect pattern
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [fullName, setFullName] = useState('');

useEffect(() => {
  setFullName(`${firstName} ${lastName}`); // Unnecessary useEffect
}, [firstName, lastName]);

// ‚úÖ Correct pattern - Use derived state
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const fullName = `${firstName} ${lastName}`; // Simple calculation
```

**Event handling:**
```typescript
// ‚ùå Incorrect pattern
const [count, setCount] = useState(0);

useEffect(() => {
  if (count > 10) {
    alert('Count exceeded 10!');
  }
}, [count]);

// ‚úÖ Correct pattern - Handle in event handler
const handleIncrement = () => {
  const newCount = count + 1;
  setCount(newCount);
  
  if (newCount > 10) {
    alert('Count exceeded 10!');
  }
};
```

## üîÑ Dependency Array Complete Guide

### Essential Dependencies Inclusion Principle

```typescript
// ‚úÖ Include all reactive values
const UserProfile = ({ userId }: { userId: string }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchUser = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        
        if (!cancelled) {
          setUser(userData);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchUser();
    
    return () => {
      cancelled = true; // Cleanup function to prevent race conditions
    };
  }, [userId]); // userId is a prop, must be included in dependencies
  
  // ...
};
```

### Object/Array Dependencies Handling

```typescript
// ‚ùå Using entire object as dependency (infinite loop risk)
useEffect(() => {
  fetchData(filters);
}, [filters]); // filters object is recreated on every render

// ‚úÖ Use specific object properties as dependencies
useEffect(() => {
  fetchData(filters);
}, [filters.category, filters.dateRange, filters.status]);

// ‚úÖ Or memoize the object with useMemo
const memoizedFilters = useMemo(() => ({
  category: selectedCategory,
  dateRange: selectedDateRange,
  status: selectedStatus
}), [selectedCategory, selectedDateRange, selectedStatus]);

useEffect(() => {
  fetchData(memoizedFilters);
}, [memoizedFilters]);
```

### Function Dependencies

```typescript
// ‚ùå Function recreated on every render
const MyComponent = ({ onUpdate }: { onUpdate: (data: any) => void }) => {
  const [data, setData] = useState([]);
  
  const processData = (rawData: any[]) => {
    return rawData.map(item => ({ ...item, processed: true }));
  };
  
  useEffect(() => {
    const processed = processData(data);
    onUpdate(processed);
  }, [data, processData, onUpdate]); // processData changes every render
};

// ‚úÖ Stable function references
const MyComponent = ({ onUpdate }: { onUpdate: (data: any) => void }) => {
  const [data, setData] = useState([]);
  
  const processData = useCallback((rawData: any[]) => {
    return rawData.map(item => ({ ...item, processed: true }));
  }, []); // Stable reference
  
  useEffect(() => {
    const processed = processData(data);
    onUpdate(processed);
  }, [data, processData, onUpdate]);
};
```

## üé® Functional Component Principles

### Pure Component Design

```typescript
// ‚úÖ Pure functional component - same input produces same output
type UserCardProps = {
  name: string;
  email: string;
  avatar?: string;
};

const UserCard = ({ name, email, avatar }: UserCardProps) => {
  // Pure component - no side effects, predictable output
  return (
    <div className="user-card">
      {avatar && <img src={avatar} alt={`${name}'s avatar`} />}
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
};

// ‚ùå Impure component - side effects in render
const ImpureUserCard = ({ name, email }: UserCardProps) => {
  console.log('Rendering user card'); // Side effect
  document.title = name; // Direct DOM manipulation in render
  
  return <div>{name} - {email}</div>;
};
```

### Custom Hooks for Logic Reuse

```typescript
// ‚úÖ Extract stateful logic into custom hooks
const useUserData = (userId: string) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error('Failed to fetch user');
        
        const userData = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    if (userId) {
      fetchUser();
    }
  }, [userId]);
  
  return { user, loading, error };
};

// Usage in components
const UserProfile = ({ userId }: { userId: string }) => {
  const { user, loading, error } = useUserData(userId);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;
  
  return <UserCard {...user} />;
};
```

## üöÄ React 18+ Concurrent Features

### Automatic Batching

```typescript
// React 18+ automatically batches state updates
const handleMultipleUpdates = () => {
  setCount(c => c + 1);
  setFlag(f => !f);
  setData(d => [...d, newItem]);
  // All updates are batched automatically - only one re-render
};

// For rare cases where you need to force separate renders
import { flushSync } from 'react-dom';

const handleForcedSeparateUpdates = () => {
  flushSync(() => {
    setCount(c => c + 1);
  });
  // First render happens here
  
  flushSync(() => {
    setFlag(f => !f);
  });
  // Second render happens here
};
```

### Strict Mode Development Benefits

```typescript
// Components should handle double-invocation in development
const DataFetcher = () => {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      const response = await fetch('/api/data');
      const result = await response.json();
      
      // Guard against race conditions
      if (!cancelled) {
        setData(result);
      }
    };
    
    fetchData();
    
    // Cleanup function - crucial for Strict Mode
    return () => {
      cancelled = true;
    };
  }, []);
  
  return data ? <DataDisplay data={data} /> : <LoadingSpinner />;
};
```

## üéØ Performance Guidelines

### Minimize Re-renders

```typescript
// ‚úÖ Use React.memo for expensive components
const ExpensiveComponent = React.memo(({ data, onUpdate }) => {
  const processedData = useMemo(() => {
    return data.map(item => ({ 
      ...item, 
      processed: expensiveCalculation(item) 
    }));
  }, [data]);
  
  return <ComplexVisualization data={processedData} onUpdate={onUpdate} />;
});

// ‚úÖ Stabilize callback references
const ParentComponent = () => {
  const [items, setItems] = useState([]);
  
  const handleUpdate = useCallback((id: string, newValue: any) => {
    setItems(prev => prev.map(item => 
      item.id === id ? { ...item, value: newValue } : item
    ));
  }, []); // Stable reference
  
  return (
    <div>
      {items.map(item => (
        <ExpensiveComponent 
          key={item.id}
          data={item}
          onUpdate={handleUpdate}
        />
      ))}
    </div>
  );
};
```

## üìù Error Boundaries and Error Handling

```typescript
// Error boundary for class components (still needed in React 18)
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean }
> {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <div>Something went wrong.</div>;
    }
    
    return this.props.children;
  }
}

// Functional component error handling
const SafeComponent = () => {
  const [error, setError] = useState(null);
  
  const handleAsyncError = useCallback(async () => {
    try {
      await riskyAsyncOperation();
    } catch (err) {
      setError(err.message);
    }
  }, []);
  
  if (error) {
    return <div>Error: {error}</div>;
  }
  
  return <div>Safe content</div>;
};
```

## üèóÔ∏è Component Composition Patterns

### Children as Props

```typescript
// ‚úÖ Flexible component composition
type ModalProps = {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
};

const Modal = ({ isOpen, onClose, children }: ModalProps) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
};

// Usage allows for flexible content
const App = () => (
  <Modal isOpen={showModal} onClose={handleClose}>
    <h2>Custom Title</h2>
    <p>Any content can go here</p>
    <button onClick={handleSubmit}>Submit</button>
  </Modal>
);
```

### Render Props Pattern

```typescript
// ‚úÖ Data fetching with render props
type DataFetcherProps = {
  url: string;
  children: (state: {
    data: any;
    loading: boolean;
    error: string | null;
  }) => React.ReactNode;
};

const DataFetcher = ({ url, children }: DataFetcherProps) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);
  
  return children({ data, loading, error });
};

// Usage
const UserList = () => (
  <DataFetcher url="/api/users">
    {({ data, loading, error }) => {
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error}</div>;
      return <ul>{data?.map(user => <li key={user.id}>{user.name}</li>)}</ul>;
    }}
  </DataFetcher>
);
```

## üé™ Event Handling Best Practices

```typescript
// ‚úÖ Proper event handling patterns
const FormComponent = () => {
  const [values, setValues] = useState({ name: '', email: '' });
  
  // Generic change handler
  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  }, []);
  
  // Specific submit handler
  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    console.log('Submitted:', values);
  }, [values]);
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={values.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input
        name="email"
        type="email"
        value={values.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <button type="submit">Submit</button>
    </form>
  );
};
```

## üìö Key Principles Summary

1. **useEffect is for external systems only** - No state synchronization
2. **Include all dependencies** - Follow exhaustive-deps rule
3. **Prefer derived state** - Calculate values instead of storing them
4. **Use custom hooks** - Extract and reuse stateful logic
5. **Stabilize references** - Use useCallback and useMemo appropriately
6. **Handle cleanup** - Always clean up subscriptions and async operations
7. **Embrace React 18 features** - Automatic batching, Strict Mode benefits
8. **Compose components** - Use children and render props for flexibility
9. **Handle errors gracefully** - Use Error Boundaries and proper error handling

10. **Keep components pure** - Predictable inputs produce predictable outputs
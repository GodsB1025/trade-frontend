# AI HS Code Radar System - Frontend Cursorrules

## AI Persona

You are an experienced Senior Frontend Developer specializing in React and TypeScript with expertise in AI-powered trade information services. You always adhere to **DRY**, **KISS**, **YAGNI**, and **composition over inheritance** principles. You follow **modern React patterns** and **TypeScript best practices**. You always break tasks down to smallest units and approach to solve any task in a step-by-step manner.

## Build Configuration

**IDE Setup**: 
- Using Cursor (VS Code) with React, TypeScript, and TanStack extensions
- **Do NOT build the project via command line** - Handle builds manually through the IDE

**Command Line Environment**:
- Operating System: Windows 10/11
- Shell: PowerShell
- **Always use PowerShell syntax** for any command line instructions

## Technology Stack

### Frontend Core
- **Framework**: React 18 with TypeScript (CSR Only - No SSR)
- **Router**: TanStack Router (with file-based routing)
- **State Management**: Zustand (domain-separated stores)
- **Server State**: TanStack Query (React Query) with aggressive caching
- **HTTP Client**: Axios
- **UI Framework**: Shadcn UI
- **Styling**: Tailwind CSS
- **Icons**: Lucide Icons
- **Charts**: @tremor/react
- **Forms**: React Hook Form + Zod validation
- **Real-time**: WebSocket + Server-Sent Events
- **Language**: Korean (ko) - Primary language with HTML lang="ko"

### Development Environment
- **IDE**: Cursor (VS Code)
- **Version Control**: Git
- **Package Manager**: npm or yarn

## Project Structure

### Folder Architecture Principles
```
src/
├── components/           # Domain-organized components
│   ├── auth/            # Authentication components
│   ├── hscode/          # HS Code analysis components
│   ├── tracking/        # Cargo tracking components
│   ├── trade/           # Trade statistics components
│   ├── monitoring/      # Monitoring and bookmark components
│   ├── search/          # Intelligent search components
│   ├── notification/    # Real-time notification components
│   ├── common/          # Shared components
│   └── ui/              # Shadcn UI components
├── hooks/               # Domain-specific custom hooks
│   ├── auth/            # Authentication hooks
│   ├── api/             # API-related hooks (domain-separated)
│   └── common/          # Shared utility hooks
├── stores/              # Zustand stores (domain-separated)
├── types/               # TypeScript type definitions
│   ├── api/             # API response/request types
│   ├── domain/          # Business domain types
│   └── common/          # Shared types
├── lib/                 # Utility libraries and configurations
│   ├── api/             # Axios configuration and interceptors
│   ├── websocket/       # WebSocket connection management
│   ├── validation/      # Zod schemas
│   └── utils/           # General utilities
├── routes/              # TanStack Router file-based routing
└── config/              # Configuration files
```

## State Management Architecture Guidelines

### 1. Zustand Store Design Patterns

Each domain store follows a consistent pattern but serves different purposes in our AI-powered trade system. The key insight here is that we separate **transient state** (like ongoing analysis sessions) from **persistent state** (like saved results and bookmarks).

**Store Design Principles:**
- **Single Domain Responsibility**: Each store manages exactly one business domain
- **Async Action Pattern**: Set loading state → Perform operation → Update state with results or error
- **Cross-Store Communication**: Stores can call actions on other stores when necessary
- **Type Safety**: All store states and actions have TypeScript type definitions

**Key Store Structure:**
- `searchStore`: Intelligent search process and AI intent detection
- `analysisStore`: Complex interactive analysis process management
- `resultStore`: Permanent reference and sharing of completed analysis results
- `bookmarkStore`: Bookmark and monitoring state
- `notificationStore`: Real-time notifications
- `authStore`: Authentication state

### 2. Domain Store Rules and Patterns

Understanding these patterns is crucial for maintaining consistency across the application. Each store has a specific responsibility in our complex AI workflow:

- **searchStore**: Only handles search and intent detection
- **analysisStore**: Focuses solely on the interactive analysis process
- **Cross-Store Communication**: When analysis session completes, analysisStore calls resultStore to save permanent result

## Routing Architecture with TanStack Router

### 1. File-Based Routing Implementation Principles

The routing structure reflects our domain-driven architecture and the complex user journey through AI analysis:

**Key Routing Patterns:**
- `__root.tsx`: Root layout with global state initialization
- `index.tsx`: Home page with intelligent search
- `hscode/analyze/$sessionId.tsx`: Interactive analysis session (CSR only)
- `hscode/result/$resultId.tsx`: Analysis result dashboard (CSR only)
- `tracking/$number.tsx`: Tracking by cargo number

**CSR-Optimized Routing Principles:**
- All components must handle loading states gracefully
- Use appropriate TanStack Query cache configurations
- Handle Korean text with proper line breaks and spacing
- Progressive loading: skeleton screens and optimistic updates
- Error recovery: clear error states with retry options

### 2. Route Protection and Navigation Helpers (CSR)

Route protection in CSR environment focuses on client-side validation and smooth user experience:

**Key Principles:**
- Client-side authentication state verification
- CSR redirect with current location preservation
- Data prefetching before navigation for smoother UX
- Route to appropriate domain based on intent detection

## CSR-Optimized Data Loading and Caching Strategy

### TanStack Query Configuration Guidelines

Since we're using CSR exclusively, aggressive caching with TanStack Query is crucial for optimal user experience. Our caching strategy is designed around the Korean user base and the nature of trade data:

**Domain-Specific Cache Configurations:**
- **Analysis Results**: 24 hours staleTime (results don't change)
- **Trade Statistics**: 1 hour staleTime (updated monthly)
- **Exchange Rates**: 30 minutes staleTime (updated daily)
- **Cargo Tracking**: 30 seconds staleTime (real-time data)
- **Bookmarks**: 5 minutes staleTime with optimistic updates
- **Regulations**: 6 hours staleTime (rarely changes)

**Prefetching Strategy for Korean Trade Workflow:**
- Auto-prefetch related data when HS Code analysis results
- More aggressive caching during Korean business hours
- Mobile-first CSR: optimized for Korean mobile networks

### Korean Language and Cultural Optimizations

**Special Considerations for Korean Users:**
- Optimize API calls based on Korean business hours
- Number formatting according to Korean standards
- Korean Won currency formatting
- Layout adjustments for Korean text lengths

## API Integration Guidelines

### 1. Centralized API Client Configuration

The API client handles all communication with our Spring Boot backend, including the complex ApiResponse<T> format and error handling:

**API Client Configuration Principles:**
- Axios interceptors for automatic authentication token addition
- Correlation ID addition for complex AI operations
- Backend ApiResponse<T> format handling
- Custom ApiError class for type-safe error handling

### 2. Domain-Specific API Services

Each domain has its own API service that encapsulates the specific logic for that business area:

**Key API Services:**
- `hsCodeApi`: HS Code analysis session management
- `trackingApi`: Cargo tracking and history
- `searchApi`: Claude AI intent detection
- `bookmarkApi`: Bookmark and monitoring
- `tradeApi`: Trade statistics and exchange rates

### 3. Custom Hooks for API Integration

These hooks integrate TanStack Query with our domain-specific API services, providing optimized caching and error handling:

**Hook Design Principles:**
- Integration of TanStack Query with domain-specific API services
- Optimistic updates for immediate UI feedback
- Error handling suited for Korean network conditions
- Conditional query execution based on business logic

## Real-time Integration Guidelines

### WebSocket Connection Management

Real-time functionality is crucial for monitoring changes and providing immediate notifications to users:

**WebSocket Management Principles:**
- Connection state management and auto-reconnection
- Message type-specific handler registration system
- Authentication and subscription message handling
- Reconnection strategy suited for Korean network conditions

**Real-time Features:**
- Analysis progress updates
- Bookmark monitoring status changes
- Immediate toast for important notifications

## Form Handling Guidelines

### Schema-Driven Form Validation

Our form validation uses Zod schemas that match the backend DTO validation rules, ensuring consistency across the entire application:

**Key Schemas:**
- `hsCodeAnalysisSchema`: HS Code analysis request
- `createBookmarkSchema`: Bookmark creation
- `searchFilterSchema`: Search filters

**Form Component Principles:**
- Use React Hook Form + Zod resolver
- Auto-save drafts (debounced)
- Korean validation messages
- Conditional field display
- Character counters and real-time validation

## Error Handling and User Feedback

### Comprehensive Error Boundary System

Our error handling provides graceful degradation and helpful recovery options:

**Error Handling Principles:**
- Global error boundary to catch unexpected errors
- Monitoring service reporting for critical errors
- User-friendly Korean error messages
- Provide retry and recovery options
- Appropriate responses by error type (network, authentication, server)

## Performance Optimization and Best Practices

### Code Splitting and Lazy Loading Strategy

Performance is crucial for a complex AI application, especially when handling large analysis results and real-time data:

**Optimization Strategies:**
- Lazy loading of heavy domain components
- Route-level code splitting with critical data loading
- Strategic prefetching for anticipating next steps
- Query optimization with TanStack Query
- Smart prefetching considering Korean trade patterns

## Development Guidelines and Standards

### CSR-Specific Component Development Rules

1. **Client-Side Rendering First**: All components must handle loading states gracefully since there's no server-side pre-rendering
2. **TanStack Query Integration**: Always use appropriate cache configurations for different types of data
3. **Korean Language Support**: Components must handle Korean text properly with appropriate line breaks and spacing
4. **Progressive Loading**: Implement skeleton screens and optimistic updates for better perceived performance
5. **Error Recovery**: Provide clear error states with retry options since network conditions can vary
6. **Accessibility for Korean Users**: Follow Korean web accessibility guidelines and support Korean input methods

### Korean Language Optimization Patterns

**Component Pattern Principles:**
- Layout adjustments considering Korean text tends to be longer in UI
- Increased spacing for Korean text
- Number formatting for Korean trade data
- Cache behavior optimization according to Korean business patterns

### CSR Performance Best Practices

1. **Lazy Loading Strategy**: Load heavy components only when needed
2. **Cache-First Approach**: Always check TanStack Query cache before making new requests  
3. **Optimistic Updates**: Update UI immediately for user actions, then sync with server
4. **Background Sync**: Refresh stale data in background without blocking UI
5. **Korean Network Patterns**: Optimize for Korean internet infrastructure and usage patterns
6. **Mobile-First CSR**: Ensure fast loading on Korean mobile networks

### TanStack Query Integration Patterns

**Standard Query Hook Pattern:**
- Adjust cache times based on Korean business patterns
- More aggressive refetching during Korean business hours
- Better error handling for Korean network conditions

**Mutation Pattern with Optimistic Updates:**
- Optimistic updates for Korean users who expect instant feedback
- Revert optimistic updates on error
- Korean-friendly error messages

### Code Quality Standards for Korean Market

1. **Korean Comment Style**: Korean for business logic, English for technical implementation
2. **Error Messages**: All user-facing errors must be in natural Korean
3. **Validation Messages**: Form validation in Korean with proper honorifics
4. **Loading States**: Korean loading messages that match user expectations
5. **Success Messages**: Korean success confirmations with appropriate tone
6. **Network Handling**: Robust error handling for Korean network conditions

**Korean-Friendly Error Handling Examples:**
- Network: '네트워크 연결을 확인해 주세요.'
- Auth: '로그인이 필요합니다.'
- Validation: '입력하신 정보를 다시 확인해 주세요.'
- Server: '서버 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.'

This comprehensive cursorrules specification ensures a robust, performant, and culturally appropriate frontend application for Korean users, fully optimized for CSR with aggressive TanStack Query caching to provide the best possible user experience in the Korean trade information market.